use dioxus::prelude::*;
use dioxus_router::prelude::*;

use crate::{
    Route,
    components::modal::{MODAL_STACK, Modal, ModalBox},
    gallery::{collections::CollectionTable, comments::CommentList, similar::SimilarMedia},
};
use api::{fold_set, full_link, media::*, unfold_set};

#[derive(Clone, PartialEq, Props)]
pub struct GalleryDetailProps {
    // this is a String because we get it from the Router
    media_uuid: String,
}

#[component]
pub fn GalleryDetail(props: GalleryDetailProps) -> Element {
    let update_signal = use_signal(|| ());

    rsx! {
        ModalBox { update_signal }
        ErrorBoundary {
            handle_error: |error: ErrorContext| {
                rsx! {
                    if let Some(error_ui) = error.show() {
                        {error_ui}
                    } else {
                        div { "GalleryDetail encountered an error.  Check the logs or reach out the the administrators." }
                    }
                }
            },
            GalleryInner { update_signal, media_uuid: props.media_uuid }
        }
    }
}

#[derive(Clone, PartialEq, Props)]
pub struct GalleryErrorProps {
    message: String,
}

#[component]
fn GalleryError(props: GalleryErrorProps) -> Element {
    rsx! {
        div { class: "container error-state",
            h1 { "Error Loading Media" }
            p { "There was an error loading the media: {props.message}" }
            Link { to: Route::GallerySearch {}, class: "btn btn-primary", "Return to Gallery" }
        }
    }
}

#[derive(Clone, PartialEq, Props)]
struct GalleryInnerProps {
    update_signal: Signal<()>,
    media_uuid: String,
}

#[component]
fn GalleryInner(props: GalleryInnerProps) -> Element {
    let mut update_signal = props.update_signal;

    // annoying parse step because the Router is String-only
    let media_uuid = props.media_uuid.parse::<MediaUuid>().show(|_| {
        let message = "The media_uuid could not be parsed".to_string();
        rsx! {
            GalleryError { message }
        }
    })?;

    // the media_uuid passed in from the Router is non-reactive, but all of the components in this
    // module will need to re-render if the media_uuid changes
    //
    // in particular, we want the core get_media() resource to re-run if we change URLs but stay
    // on the same "page", mostly by clicking media in the "similar media" section
    let media_uuid = use_memo(use_reactive(&media_uuid, |media_uuid| media_uuid));

    // this is the api call that actually does all of the work, defined in the api crate so that
    // the struct defintions are shared with the server
    //
    // we also subscribe this future to the update_signal to trigger a complete refresh, since
    // modal boxes do their own api calls and might change any part of the media db record
    let media_future = use_resource(move || async move {
        update_signal();
        let media_uuid = media_uuid();

        get_media(&GetMediaReq { media_uuid }).await
    });

    // this subscribes the whole component to the use_resource() reactive variable
    let media_data = &*media_future.read();

    // converting the option to an error and bubbling it up results in the page never reloading, so we
    // transpose to handle the possible error first (via show(), which causes the outer component to
    // render the GalleryError) and then match/return early for the Option
    //
    // TODO -- find a way to implement this without a clone()
    let media_data = match media_data.clone().transpose().show(|error| {
        rsx! {
            GalleryError { message: error }
        }
    })? {
        None => {
            return rsx! {
                GalleryDetailSkeleton {}
            };
        }
        Some(v) => v,
    };

    // subscribe other elements via memos
    let collection_uuids = use_memo(move || match &*media_future.read() {
        Some(Ok(v)) => v.collections.clone(),
        _ => Vec::new(),
    });

    let comment_uuids = use_memo(move || match &*media_future.read() {
        Some(Ok(v)) => v.comments.clone(),
        _ => Vec::new(),
    });

    // extract the parts of the message
    let media = media_data.media;

    // hypothetically we could display many status updates here, but currently it is
    // used only for the UpdateMedia calls generated by the main form
    let mut status_signal = use_signal(|| String::from(""));

    // tag sets fetched via the endpoints *should* always re-fold safely, but we still
    // want to guard against clobbering anything in the case that something goes wrong
    let mut valid_tags = true;
    let formatted_tags = fold_set(media.tags).unwrap_or_else(|_| {
        valid_tags = false;
        "invalid tags, contact admins".to_string()
    });

    rsx! {
        div { class: "container",
            div { class: "breadcrumb",
                Link { to: Route::GallerySearch {}, "Gallery" }
                span { " / " }
                span { "Media Details" }
            }

            // side-by-side layout with independent scrolling
            div { class: "media-detail-page",

                // left column -- Media display (fixed position)
                div { class: "media-detail-main",

                    // main media display
                    div { class: "media-detail-view",
                        match media.metadata {
                            MediaMetadata::Image => rsx! {
                                img {
                                    class: "media-detail-image",
                                    src: full_link(media_uuid()),
                                    onclick: move |_| {
                                        MODAL_STACK.with_mut(|v| v.push(Modal::EnhancedImageView(media_uuid())));
                                    },
                                }
                            },
                            MediaMetadata::Video => rsx! {
                                video {
                                    class: "media-detail-video",
                                    src: full_link(media_uuid()),
                                    controls: true,
                                }
                            },
                            _ => rsx! {
                                div { class: "unsupported-media", "This media type is not supported for preview" }
                            },
                        }
                    }

                    SimilarMedia { media_uuid }
                }

                // right column -- all metadata, collections, and comments (scrollable)
                div { class: "media-detail-sidebar",

                    // media metadata form
                    div { class: "detail-section",
                        form {
                            class: "media-detail-form",
                            onsubmit: move |event| async move {
                                let date = event.values().get("date").map(|v| v.as_value());
                                let note = event.values().get("note").map(|v| v.as_value());
                                let tags = if valid_tags {
                                    event
                                        .values()
                                        .get("tags")
                                        .map(|v| v.as_value())
                                        .map(|s| unfold_set(s.trim()))
                                } else {
                                    None
                                };
                                match update_media(
                                        &UpdateMediaReq {
                                            media_uuid: media_uuid(),
                                            update: MediaUpdate {
                                                hidden: None,
                                                date,
                                                note,
                                                tags,
                                            },
                                        },
                                    )
                                    .await
                                {
                                    Ok(_) => {
                                        status_signal.set("Changes saved successfully".to_string());
                                        update_signal.set(());
                                    }
                                    Err(err) => {
                                        status_signal.set(format!("Error: {}", err));
                                    }
                                }
                            },

                            h2 { "Media Information" }

                            div {
                                class: "form-row",
                                style: "display: flex; gap: var(--space-4);",
                                div { class: "form-group", style: "flex: 1;",
                                    label { class: "form-label", "Library" }
                                    input {
                                        class: "form-input",
                                        r#type: "text",
                                        value: "{media.library_uuid}",
                                        disabled: true,
                                    }
                                }

                                div { class: "form-group", style: "flex: 1;",
                                    label { class: "form-label", "Path" }
                                    input {
                                        class: "form-input",
                                        r#type: "text",
                                        value: "{media.path}",
                                        disabled: true,
                                    }
                                }
                            }

                            div {
                                class: "form-row",
                                style: "display: flex; gap: var(--space-4); align-items: flex-end;",
                                div { class: "form-group", style: "flex: 1;",
                                    label { class: "form-label", "Date" }
                                    input {
                                        class: "form-input",
                                        name: "date",
                                        r#type: "text",
                                        value: "{media.date}",
                                    }
                                }

                                div {
                                    class: "form-group form-checkbox",
                                    style: "margin-bottom: var(--space-6);",
                                    input {
                                        id: "hidden-checkbox",
                                        style: "margin: 0 8px 0 0;",
                                        r#type: "checkbox",
                                        checked: media.hidden,
                                        onclick: move |_| async move {
                                            match update_media(
                                                    &UpdateMediaReq {
                                                        media_uuid: media_uuid(),
                                                        update: MediaUpdate {
                                                            hidden: Some(!media.hidden),
                                                            date: None,
                                                            note: None,
                                                            tags: None,
                                                        },
                                                    },
                                                )
                                                .await
                                            {
                                                Ok(_) => {
                                                    status_signal.set("Visibility updated".to_string());
                                                    update_signal.set(());
                                                }
                                                Err(err) => {
                                                    status_signal.set(format!("Error: {}", err));
                                                }
                                            }
                                        },
                                    }
                                    label { r#for: "hidden-checkbox", "Hidden" }
                                }
                            }

                            div { class: "form-group",
                                label { class: "form-label", "Note" }
                                textarea {
                                    class: "form-textarea",
                                    name: "note",
                                    rows: 3,
                                    value: "{media.note}",
                                }
                            }

                            div {
                                class: "form-row",
                                style: "display: flex; gap: var(--space-4);",
                                div { class: "form-group", style: "flex: 1;",
                                    label { class: "form-label", "Tags" }
                                    input {
                                        class: "form-input",
                                        name: "tags",
                                        r#type: "text",
                                        value: "{formatted_tags}",
                                    }
                                }
                            }

                            div {
                                class: "form-actions",
                                style: "display: flex; align-items: center; gap: var(--space-4);",
                                button {
                                    class: "btn btn-primary",
                                    r#type: "submit",
                                    "Save Changes"
                                }

                                button {
                                    class: "btn btn-secondary",
                                    // don't submit despite being part of the form
                                    r#type: "button",
                                    onclick: move |_| {
                                        let link = full_link(media_uuid());
                                        let window = web_sys::window().expect("no global window exists");
                                        let _ = window.open_with_url_and_target(&link, "_blank");
                                    },
                                    "Download Original"
                                }

                                if !status_signal().is_empty() {
                                    span {
                                        class: "status-message",
                                        style: "color: var(--secondary);",
                                        "{status_signal()}"
                                    }
                                }
                            }
                        }
                    }

                    // collections section
                    //
                    // currently, all relevant state changes happen through modals
                    // which have the update_signal already
                    CollectionTable { collection_uuids, media_uuid }

                    // comments section
                    //
                    // while some comment actions are in modals, creating comments
                    // requires its own update_signal hook
                    CommentList {
                        comment_uuids,
                        media_uuid,
                        update_signal,
                    }

                    // padding at the bottom to ensure good scrolling
                    div { style: "height: var(--space-4);" }
                }
            }
        }
    }
}

#[component]
fn GalleryDetailSkeleton() -> Element {
    rsx! {
        div { class: "container loading-state",
            div {
                class: "skeleton",
                style: "height: 40px; width: 200px; margin-bottom: 16px;",
            }
            div {
                class: "media-detail-page skeleton-layout",
                style: "display: flex; gap: var(--space-6);",

                // Left column skeleton
                div { style: "flex: 0 0 50%;",
                    div {
                        class: "skeleton",
                        style: "height: 400px; margin-bottom: 16px;",
                    }
                }

                // Right column skeleton
                div { style: "flex: 1;",
                    div {
                        class: "skeleton",
                        style: "height: 24px; width: 80%; margin-bottom: 8px;",
                    }
                    div {
                        class: "skeleton",
                        style: "height: 24px; width: 60%; margin-bottom: 8px;",
                    }
                    div {
                        class: "skeleton",
                        style: "height: 100px; margin-bottom: 16px;",
                    }
                    div {
                        class: "skeleton",
                        style: "height: 150px; margin-bottom: 16px;",
                    }
                }
            }
        }
    }
}
